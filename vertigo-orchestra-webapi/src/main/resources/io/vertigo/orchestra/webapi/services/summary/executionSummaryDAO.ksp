package io.vertigo.orchestra.webapi.dao.summary

create Task TK_GET_EXECUTION_SUMMARIES_BY_DATE {
    className : "io.vertigo.dynamox.task.TaskEngineSelect"
        request : "
        	select 	distinct 
        			(select pro1.PRO_ID from o_process pro1 where pro1.name = pro.name and pro1.active is true) as PRO_ID,
        			pro.NAME as PROCESS_NAME,
        			round(extract('epoch' from avg(pre.END_TIME-pre.BEGIN_TIME) over w )) as AVERAGE_EXECUTION_TIME,
        			sum(case when pre.est_cd='DONE' then 1 else 0 end) over w as SUCCESSFUL_COUNT,
        			sum(case when pre.est_cd='ERROR' then 1 else 0 end) over w as ERRORS_COUNT,
        			(select max(pre2.begin_time) from o_process_execution pre2 join o_process p2 on p2.pro_id=pre2.pro_id where p2.name=pro.name group by p2.name )
        				as LAST_EXECUTION_TIME,
        			(select sum(case when prp.pst_cd='MISFIRED' then 1 else 0 end) 
        					from o_process_planification prp join o_process p2 on p2.pro_id=prp.pro_id where p2.name=pro.name and prp.expected_time between #DATE_MIN# and #DATE_MAX# group by p2.name)
			  			as MISFIRED_COUNT,
			  		(select min(prp.expected_time) 
			  				from o_process_planification prp join o_process p2 on p2.pro_id=prp.pro_id where p2.name=pro.name and prp.pst_cd='WAITING' group by p2.name)
						as NEXT_EXECUTION_TIME
			from o_process pro
			Join o_process_execution pre on pro.pro_id = pre.pro_id
			where pre.begin_time between #DATE_MIN# and #DATE_MAX#
			WINDOW w as (PARTITION by pro.name);
        	
			"
	attribute DTC_EXECUTION_SUMMARY	 	{domain : DO_DT_O_EXECUTION_SUMMARY_DTC 		notNull:"true" 	inOut :"out"}
	attribute DATE_MIN	 	{domain : DO_O_TIMESTAMP 		notNull:"true" 	inOut :"in"}
	attribute DATE_MAX	 	{domain : DO_O_TIMESTAMP 		notNull:"true" 	inOut :"in"}
},

create Task TK_GET_EXECUTION_SUMMARY_BY_DATE_AND_NAME {
    className : "io.vertigo.dynamox.task.TaskEngineSelect"
        request : "
        	select 	distinct 
        			(select pro1.PRO_ID from o_process pro1 where pro1.name = pro.name and pro1.active is true) as PRO_ID,
        			pro.NAME as PROCESS_NAME,
        			round(extract('epoch' from avg(pre.END_TIME-pre.BEGIN_TIME) over w)) as AVERAGE_EXECUTION_TIME,
        			sum(case when pre.est_cd='DONE' then 1 else 0 end) over w as SUCCESSFUL_COUNT,
        			sum(case when pre.est_cd='ERROR' then 1 else 0 end) over w as ERRORS_COUNT,
        			(select max(pre2.begin_time) from o_process_execution pre2 join o_process p2 on p2.pro_id=pre2.pro_id where p2.name=pro.name group by p2.name )
        				as LAST_EXECUTION_TIME,
        			(select sum(case when prp.pst_cd='MISFIRED' then 1 else 0 end) 
        					from o_process_planification prp join o_process p2 on p2.pro_id=prp.pro_id where p2.name=pro.name and prp.expected_time between #DATE_MIN# and #DATE_MAX# group by p2.name)
			  			as MISFIRED_COUNT,
			  		(select min(prp.expected_time) 
			  				from o_process_planification prp join o_process p2 on p2.pro_id=prp.pro_id where p2.name=pro.name and prp.pst_cd='WAITING' group by p2.name)
						as NEXT_EXECUTION_TIME
			from o_process pro
			Join o_process_execution pre on pro.pro_id = pre.pro_id
			where pre.begin_time between #DATE_MIN# and #DATE_MAX# and pro.NAME = #NAME#
			WINDOW w as (PARTITION by pro.name);
        	
			"
	attribute DT_EXECUTION_SUMMARY	 	{domain : DO_DT_O_EXECUTION_SUMMARY_DTO 		notNull:"true" 	inOut :"out"}
	attribute DATE_MIN	 	{domain : DO_O_TIMESTAMP 		notNull:"true" 	inOut :"in"}
	attribute DATE_MAX	 	{domain : DO_O_TIMESTAMP 		notNull:"true" 	inOut :"in"}
	attribute NAME	 		{domain : DO_O_LIBELLE 		notNull:"true" 	inOut :"in"}
},