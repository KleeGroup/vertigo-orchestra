package io.vertigo.orchestra.webapi.dao.summary

create Task TK_GET_EXECUTION_SUMMARIES_BY_DATE {
    className : "io.vertigo.dynamox.task.TaskEngineSelect"
        request : "
        	select 	distinct 
        			(select pro1.PRO_ID from o_process pro1 where pro1.name = pro.name and pro1.active_version is true) as PRO_ID,
        			pro.NAME as PROCESS_NAME,
        			round(extract('epoch' from avg(pre.END_TIME-pre.BEGIN_TIME) over w )) as AVERAGE_EXECUTION_TIME,
        			sum(case when pre.est_cd='DONE' then 1 else 0 end) over w as SUCCESSFUL_COUNT,
        			sum(case when pre.est_cd='ERROR' then 1 else 0 end) over w as ERRORS_COUNT,
        			max(pre.begin_time) over w as LAST_EXECUTION_TIME,
        			mis_sub.MISFIRED_COUNT as MISFIRED_COUNT,
					next_sub.NEXT_EXECUTION_TIME as NEXT_EXECUTION_TIME
			from o_process pro
			left join o_process_execution pre on pro.pro_id = pre.pro_id,
			LATERAL (select count(prp.prp_Id) as MISFIRED_COUNT
        					from o_process_planification prp join o_process p2 on p2.pro_id=prp.pro_id where p2.name=pro.name and prp.pst_cd='MISFIRED' and prp.expected_time between #DATE_MIN# and #DATE_MAX# )
			  			as mis_sub,
			LATERAL (select min(prp.expected_time) as NEXT_EXECUTION_TIME
			  				from o_process_planification prp join o_process p2 on p2.pro_id=prp.pro_id where p2.name=pro.name and prp.pst_cd='WAITING' )
						as next_sub	
			where pre.begin_time between #DATE_MIN# and #DATE_MAX#
			WINDOW w as (PARTITION by pro.name);
        	
			"
	attribute DTC_EXECUTION_SUMMARY	 	{domain : DO_DT_O_EXECUTION_SUMMARY_DTC 		notNull:"true" 	inOut :"out"}
	attribute DATE_MIN	 	{domain : DO_O_TIMESTAMP 		notNull:"true" 	inOut :"in"}
	attribute DATE_MAX	 	{domain : DO_O_TIMESTAMP 		notNull:"true" 	inOut :"in"}
},

create Task TK_GET_EXECUTION_SUMMARY_BY_DATE_AND_NAME {
    className : "io.vertigo.dynamox.task.TaskEngineSelect"
        request : "
        	select 	distinct 
        			(select pro1.PRO_ID from o_process pro1 where pro1.name = pro.name and pro1.active_version is true) as PRO_ID,
        			pro.NAME as PROCESS_NAME,
        			round(extract('epoch' from avg(pre.END_TIME-pre.BEGIN_TIME) over w)) as AVERAGE_EXECUTION_TIME,
        			sum(case when pre.est_cd='DONE' then 1 else 0 end) over w as SUCCESSFUL_COUNT,
        			sum(case when pre.est_cd='ERROR' then 1 else 0 end) over w as ERRORS_COUNT,
        			max(pre.begin_time) over w as LAST_EXECUTION_TIME,
        			mis_sub.MISFIRED_COUNT as MISFIRED_COUNT,
					next_sub.NEXT_EXECUTION_TIME as NEXT_EXECUTION_TIME
			from o_process pro
			left join o_process_execution pre on pro.pro_id = pre.pro_id,
			LATERAL (select count(prp.prp_Id) as MISFIRED_COUNT
        					from o_process_planification prp join o_process p2 on p2.pro_id=prp.pro_id where p2.name=pro.name and prp.pst_cd='MISFIRED' and prp.expected_time between #DATE_MIN# and #DATE_MAX# )
			  			as mis_sub,
			LATERAL (select min(prp.expected_time) as NEXT_EXECUTION_TIME
			  				from o_process_planification prp join o_process p2 on p2.pro_id=prp.pro_id where p2.name=pro.name and prp.pst_cd='WAITING' )
						as next_sub
			where case when pre.begin_time is not null then pre.begin_time between #DATE_MIN# and #DATE_MAX# else 1=1 end
			and pro.NAME = #NAME#
			WINDOW w as (PARTITION by pro.name);
        	
			"
	attribute DT_EXECUTION_SUMMARY	 	{domain : DO_DT_O_EXECUTION_SUMMARY_DTO 		notNull:"true" 	inOut :"out"}
	attribute DATE_MIN	 	{domain : DO_O_TIMESTAMP 		notNull:"true" 	inOut :"in"}
	attribute DATE_MAX	 	{domain : DO_O_TIMESTAMP 		notNull:"true" 	inOut :"in"}
	attribute NAME	 		{domain : DO_O_LIBELLE 		notNull:"true" 	inOut :"in"}
},